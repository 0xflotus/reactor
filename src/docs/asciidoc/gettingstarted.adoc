[[getting-started]]
== *Introducing Reactor*

[quote, Preface, TL;DR]
Reactor is a companion of choice for any demanding _realtime_ *Data Streaming* use cases that are designed with *Latency* and *Fault-Tolerance* in mind.

[[start]]
=== What is Reactor ?

So you came to have a look at Reactor, maybe typing some keywords in your favorite search engine like _Reactive_,
_Spring+Reactive_, _Asynchronous+Java_ or just _What the heck is Reactor_.

In a nutshell Reactor is a lightweight JVM foundation that deals with *asynchronous* message-passing _efficiently_.

.What means efficiency here is down to a few factors:
****
* How do you deal with *memory* garbage generated just to pass a message from A to B ?
* How do you handle *overflow* when a consumer is temporarely or permanentely slower than your producing resource ?
* How do you control the *asynchronous flow* without using blocking producing resources ?
****

From empiric studies (mostly rage tweets), we know that asynchronous programming is hard,
especially when a platform like the JVM offers so many options.
In fact Reactor aims to be truely non-blocking for a maximum of interactions and we offer an API to discourage the use of:

* Blocking wait : e.g. Future._get()_
* Unsafe data access : e.g. ReentrantLock._lock()_
* Exception Bubbles : e.g. try...catch...finally
* Synchronization blocks : e.g. synchronized{ }
* Enveloppe Allocation (GC Pressure) : e.g. new Enveloppe<T>(event)

Being non-blocking matters, especially when messaging scale relatively becomes important (10k msg/s, 100k msg/s 1M...).
There is some theory behind (see http://en.wikipedia.org/wiki/Amdahl%27s_law[Amdahl's Law]),
 but let's first call for some good sense. Let's say you use a pure https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html[Executor] approach.

[source,java]
----
private ExecutorService  threadPool = Executors.newFixedThreadPool(8);

final List<T> batches = new ArrayList<T>();

Callable<T> t = new Callable<T>() // <1>
{
   public T run()
   {
        synchronized(batches){ // <2>
	        T result = callDatabase(msg); // <3>
          batches.add(result);
          return result;
        }
   }
};

Future<T> f = threadPool.submit(t); // <4>
T result = f.get() // <5>
----
1> Allocate Callable, might lead to GC pressure
2> Synchronization will force stop-and-check for every threads
3> Potentially runs relatively slower than producer execution rate
4> Use a Queue based system to pass the task to the target thread
5> Block on callDatabase reply

In this simple example we want to demonstrate it is not going to scale-up as expected:

* Allocating objects might cause *GC pauses* especially if the tasks are there to stay long
** GC Pause will cause overall degradation of performances
* The Queue comes *unbounded* by default and because of the slower database call, tasks will pile up
** It's not considered as a Memory Leak but still its side effects are nasty: more work for the JVM GC scan, risk to loose important chunks of data...
** In addition, classic Linked Queues also generate memory pressure by allocating Nodes
* Finally the vicious circle kicks-in when *blocking replies* are used
** Blocking replies will cause producer slow-down. In the end the flow becomes relatively synchronous since we have to wait for each reply before submitting more tasks.
** Any callDatabase Exception will be passed in an uncontrolled fashion to the producer, negating any fault-tolerance normally offered by the thread boundary.

Non-blocking is hard to achieve, and especially now in a world of distributed systems, fashionly called MicroService Architecture
for the common hackernews/cloud reader. Reactor makes little compromises over JVM performances and tries to leverage the best patterns around
to make the developper task looks not like a mathematical thesis. We have accepted the fact that nothing travels faster than light, and
latency is a real-world concern every system might have to deal with at some point.

.We offer a framework that lets you mitigate latency nasty side-effects in your application, and we do it in a minimal overhead fashion:
****
* Leveraging some smart structures, we traded-off the *allocation issue* at runtime with pre-allocation at startup-time.
* Our main message-passing structures come *bounded* so we don't pile up tasks infinitely.
* Using popular patterns such as *Reactive and Event-Driven Architectures*, we offer *non-blocking end-to-end flows* including replies.
* Implementing the new <<gettingstarted.adoc#reactivestreams,Reactive Streams>> Standard, we made bounded structures *efficient* by not requesting more than their current capacity.
* We applied these concepts to <<net.adoc#net-overview,IPC>> and provide *non-blocking IO drivers* that understand flow-control.
* We expose a Functional API to help developers organizing their code in a *side-effect free* way. Understand by side-effect you can determine where you are thread-safe and fault-tolerant.
****


=== About the Project

The project started in 2012, with a long internal incubation time, then Reactor 1.x appeared in 2013.
Reactor 1 has been implemented successfully by different organizations: Open Source (e.g. Metldown) and Commercial (e.g. Pivotal RTI).
In 2014 we started collaborating on the emerging <<gettingstarted.adoc/#reactivestreams,Reactive Streams Standard>> and proceeded to a massive re-engineering targeting April 2015 version 2.0.1.RELEASE.
The standard closed the last gap our _Dispatching_ mechanism was still having: controlling how much in-flight data was possibly hitting our boundaries.

Parallel to that work we also decided to re-align some of our Event-Driven and Task Coordination API to the increasingly popular and documented <<gettingstarted.adoc/#rx,Reactive Extensions>>.

Reactor is sponsored by http://pivotal.io[Pivotal] where the two core committers actually work. We do try to provide an incentive to our cousin Spring user base.
However we do not force our community into adopting Spring and we remain an embedable toolkit for the mass (Well, wait to see the goodies offered by those guys).
In fact one of the Reactor goals is to stay non-opinonated in the way you solve your asynchronous and functional issues.

Reactor is http://www.apache.org/licenses/LICENSE-2.0.html[Apache 2.0 licensed] and available on https://github.com/reactor/reactor[GitHub].

=== Requirements

* Reactor needs Java 7 at least to execute.
** The full expressive potential happens with Java 8 Lambdas.
** As a fallback have a look at Spring, Clojure or Groovy extensions
* Reactor runs at full capacity when the JVM supports *Unsafe* access (e.g., not the case for Android)
** All *RingBuffer* based features will not work when Unsafe is missing
* Reactor is packaged as JAR archives and can be pulled in any project as a dependency

[[architecture]]
=== Architecture Overview
.The main modules present in Reactor 2
image::images/modules.png[Module Organization, width=500]

Reactor comes with different jars in the hope you pick the ones that suit your needs.
However some will transitively depend on lower level modules, commonly *core*, sometimes *streams* and *bus*.
Some examples combining them:

* RxJavaReactiveStreams + RxJava + Reactor-Core : Combine rich composition with efficient asynchronous IO Processor
* RxJavaReactiveStreams + RxJava + Reactor-Net (Core/Stream) : Compose input data with RxJava and gate with Async IO drivers.
* Spring XD + Reactor-Net (Core/Stream) : Use Reactor as a Sink/Source IO driver.
* Grails + Reactor-Stream (Core) : Use Promise for background Processing.
* Spring Data + Reactor-Bus (Core) : Emits Database Events (Save/Delete/...).
* Spring Integration Java DSL + Reactor Stream (Core) : Microbatch MessageChannel from Spring Integration.

.A *quick* insight into how modules use each other
image::images/overview.png[Architecture Overview, width=500]

[[reactivestreams]]
=== Reactive Streams

http://www.reactive-streams.org[Reactive Streams] is a new standard, adopted by different vendors and tech industrials including Oracle with a target to include the specification into Java 9 and onwards.

The aim of the standard is to provide (a)synchronous data sequences with a flow-control mechanism. The specification is fairly light and first targets the JVM.
It comes with 4 Java Interfaces, a TCK and a handful of examples. It is quite straightforward to implement the 4 interfaces for the need,
but the meat of the project is actually the behaviors verified by the TCK. A provider is qualified _Reactive Streams Ready_ since
it successfully passed the TCK for the implementing classes, which fortunately we did.

.The Reactive Streams Contract
image::images/rs.png[The Reactive Streams Contract, width=500]

.The Reactive Streams Interfaces
****
* https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Publisher.java[org.reactivestreams.Pubslisher]: A source of data (from 0 to N signals where N can be unlimited). It optionally provides for 2 terminal events: error and completion.
* https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Subscriber.java[org.reactivestreams.Subscriber]: A consumer of a data sequence (from 0 to N signals where N can be unlimited). It receives a subscription on initialization to _request_ how many data it wants to process next. The other callbacks interact with the data sequence signals: next (new message) and the optional completion/error.
* https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Subscription.java[org.reactivestreams.Subscription]: A small tracker passed on initialization to the Subscriber. It controls how many data we are ready to consume and when do we want to stop consuming (cancel).
* https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Processor.java[org.reactivestreams.Processor]: A marker for components that are both Subscriber and Publisher!
****

.The Reactive Streams publishing protocol
image::images/signals.png[The Publishing Sequence, width=500]

.There are two ways to request data from a Publisher, through the passed Subscription:
****
* *Unbounded*: On Subscribe, just call _Subscription#request(Long.MAX_VALUE)_.
* *Bounded*: On Subscribe, keep a reference to Subscription and hit its _request(long)_ method when the Subscriber is ready to process data.
** Typically, Subscribers will request an initial set of data, or even 1 data on Subscribe
** Then after onNext has been deemed successful (e.g. after Commit, Flush etc...), request more data
** It is encouraged to use a determined number of requests. Try avoiding overlapping requests, e.g. requesting 10 more data every next signal.
****

.What are the artifacts that Reactor directly use so far:
[cols="4*", options="header"]
|===

|Reactive Streams
|Reactor Module(s)
|Implementation(s)
|Description

|Processor
|reactor-core, reactor-stream
|reactor.core.processor.\*, reactor.rx.*
|In Core, we offer backpressure-ready RingBuffer*Processor and more, in Stream we have a full set of Operations and Broadcasters.

|Publisher
|reactor-core, reactor-bus, reactor-stream, reactor-net
|reactor.core.processor.\*, reactor.rx.stream.*, reactor.rx.action.\*, reactor.io.net.*
|In Core, processors implement Publisher. In Bus we publish an unbounded emission of routed events. In Stream, our Stream extensions directly implement Publisher. In Net, Channels are implements Publisher to consume incoming data, we also provide publishers for flush and close callbacks.

|Subscriber
|reactor-core, reactor-bus, reactor-stream, reactor-net
|reactor.core.processor.\*, reactor.bus.EventBus.*, reactor.rx.action.\*, reactor.io.net.impl.*
|In Core, our processor implement Subscriber. In Bus, we expose bus capacities with unbounded Publisher/Subscriber. In Stream, actions are Subscribers computing specific callbacks. In Net, our IO layer implements subscribers to handle writes, closes and flushes.

|Subscription
|reactor-stream, reactor-net
|reactor.rx.subscription.\*, reactor.io.net.impl.*
|In Stream, we offer optimized PushSubscriptions and buffering-ready ReactiveSubscription. In Net, our Async IO reader-side use custom Subscriptions to implement backpressure.


|===

We have worked with the standard since the inception of Reactor 2 and progressed in our journey until the *1.0.0* was about to release.
It is now available on _Maven Central_ and other popular mirrors. You will also find it as a *transitive dependency to reactor-core*.

[[rx]]
=== Reactive Extensions

Reactive Extensions, or more commonly https://msdn.microsoft.com/en-gb/data/gg577609.aspx[Rx],
are a set of well-defined Functional APIs extending the Observer pattern to an epic scale.

.Rx patterns support implementing Reactive data sequences handling with a few design keys:
* Abstract the time/latency away with a callback chain: only called when data is available
* Abstract the threading model away: Synchronous or Asynchronous it is just an _Observable_ / _Stream_ we deal with
* Control error-passing and terminations: error and complete signals in addition to the data payload signal are passed to the chain
* Solve multiple scatter-aggregation and other composition issues in various predefined API.

The standard implementation of Reactive Extensions in the JVM is https://github.com/ReactiveX/RxJava[RxJava].
It provides a powerful functional API and ports mostly all the concept over from the original Microsoft library.

Reactor 2 provides a <<streams.adoc#streams,specific module>> implementing a subset of the documented Reactive Extensions and on a very few occasion adapting the name
to match our specific behavior. This focused approach around data-centric issues (microbatching, composition...) is depending on
Reactor <<core.adoc#core-functional,Functional>> units, <<core.adoc#core-dispatchers,Dispatchers>> and the <<gettingstarted.adoc#reactivestreams, Reactive Streams>> contract.
We encourage users who need the full flavor of Reactive Extensions to try out RxJava and https://github.com/ReactiveX/RxJavaReactiveStreams[bridge with us].
In the end the user can benefit from powerful asynchronous and IO capacities provided by Reactor while composing with the complete RxJava ecosystem.

NOTE: Some operations, behaviors, and the immediate understanding of Reactive Streams are still unique to Reactor as of now and we will try to flesh out
the unique features in the <<streams.adoc#streams,appropriate section>>.

IMPORTANT: <<net.adoc#net-overview,Async IO>> capabilities are also depending on _Stream Capacity_ for
backpressure and auto-flush options.

.Misalignments between Rx and Reactor Streams
[cols="3*", options="header"]
|===

|rx
|reactor-stream
|Comment

|Observable
|reactor.rx.Stream
|Reflect the implementation of the Reactive Stream Publisher

|Operator
|reactor.rx.action.Action
|Reflect the implementation of the Reactive Stream Processor

|Observable with 1 data at most
|reactor.rx.Promise
|Type a unique result, reflect the implementation of the Reactive Stream Processor and provides for optional asynchronous dispatching.

|Factory API (just, from, merge....)
|reactor.rx.Streams
|Aligned with a core data-focused subset, return Stream

|Functional API (map, filter, take....)
|reactor.rx.Stream
|Aligned with a core data-focused subset, return Stream

|Schedulers
|reactor.core.Dispatcher, org.reactivestreams.Processor
|Reactor Streams compute operations with unbounded shared Dispatchers or bounded Processors

|Observable.observeOn()
|Stream.dispatchOn()
|Just an adapted naming for the dispatcher argument

|===