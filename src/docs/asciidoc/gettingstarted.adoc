[[getting-started]]
== *Introducing Reactor*

[quote, Preface, TL;DR]
Reactor is a companion of choice for any demanding _realtime_ *Data Streaming* use cases that are designed with *Latency* and *Fault-Tolerance* in mind.

[[start]]
=== What is Reactor ?

So you came to have a look at Reactor, maybe typing some keywords in your favorite search engine like _Reactive_,
_Spring+Reactive_, _Asynchronous+Java_ or just _What the heck is Reactor_.

In a nutshell Reactor is a lightweight JVM foundation that deals with *asynchronous* message-passing _efficiently_.

.What means efficiency here is down to a few factors:
****
* How do you deal with *memory* garbage generated just to pass a message from A to B ?
* How do you handle *overflow* when a consumer is temporarely or permanentely slower than your producing resource ?
* How do you control the *asynchronous flow* without using blocking producing resources ?
****

From empiric studies (mostly rage tweets), we know that asynchronous programming is hard,
especially when a platform like the JVM offers so many options.
In fact Reactor aims to be truely non-blocking for a maximum of interactions and we offer an API to discourage the use of:

* Blocking wait : e.g. Future._get()_
* Unsafe data access : e.g. ReentrantLock._lock()_
* Exception Bubbles : e.g. try...catch...finally
* Synchronization blocks : e.g. synchronized{ }
* Enveloppe Allocation (GC Pressure) : e.g. new Enveloppe<T>(event)

Being non-blocking matters, especially when messaging scale relatively becomes important (10k msg/s, 100k msg/s 1M...).
There is some theory behind (see http://en.wikipedia.org/wiki/Amdahl%27s_law[Amdahl's Law]),
 but let's first call for some good sense. Let's say you use a pure https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html[Executor] approach.

[source,java]
----
private ExecutorService  threadPool = Executors.newFixedThreadPool(8);

final List<T> batches = new ArrayList<T>();

Callable<T> t = new Callable<T>() // <1>
{
   public T run()
   {
        synchronized(batches){ // <2>
	        T result = callDatabase(msg); // <3>
          batches.add(result);
          return result;
        }
   }
};

Future<T> f = threadPool.submit(t); // <4>
T result = f.get() // <5>
----
1> Allocate Callable, might lead to GC pressure
2> Synchronization will force stop-and-check for every threads
3> Potentially runs relatively slower than producer execution rate
4> Use a Queue based system to pass the task to the target thread
5> Block on callDatabase reply

In this simple example we want to demonstrate it is not going to scale-up as expected:

* Allocating objects might cause *GC pauses* especially if the tasks are there to stay long
** GC Pause will cause overall degradation of performances
* The Queue comes *unbounded* by default and because of the slower database call, tasks will pile up
** It's not considered as a Memory Leak but still its side effects are nasty: more work for the JVM GC scan, risk to loose important chunks of data...
** In addition, classic Linked Queues also generate memory pressure by allocating Nodes
* Finally the vicious circle kicks-in when *blocking replies* are used
** Blocking replies will cause producer slow-down. In the end the flow becomes relatively synchronous since we have to wait for each reply before submitting more tasks.
** Any callDatabase Exception will be passed in an uncontrolled fashion to the producer, negating any fault-tolerance normally offered by the thread boundary.

Non-blocking is hard to achieve, and especially now in a world of distributed systems, fashionly called MicroService Architecture
for the common hackernews/cloud reader. Reactor makes little compromises over JVM performances and tries to leverage the best patterns around
to make the developper task looks not like a mathematical thesis. We have accepted the fact that nothing travels faster than light, and
latency is a real-world concern every system might have to deal with at some point.

.We offer a framework that lets you mitigate latency nasty side-effects in your application, and we do it in a minimal overhead fashion:
****
* Leveraging some smart structures, we traded-off the *allocation issue* at runtime with pre-allocation at startup-time.
* Our main message-passing structures come *bounded* so we don't pile up tasks infinitely.
* Using popular patterns such as *Reactive and Event-Driven Architectures*, we offer *non-blocking end-to-end flows* including replies.
* Implementing the new <<gettingstarted.adoc#reactivestreams,Reactive Streams>> Standard, we made bounded structures *efficient* by not requesting more than their current capacity.
* We applied these concepts to <<net.adoc#net-overview,IPC>> and provide *non-blocking IO drivers* that understand flow-control.
* We expose a Functional API to help developers organizing their code in a *side-effect free* way. Understand by side-effect you can determine where you are thread-safe and fault-tolerant.
****


=== About the Project

The project started in 2012, with a long internal incubation time, then Reactor 1.x appeared in 2013.
Reactor 1 has been implemented successfully by different organizations: Open Source (e.g. Metldown) and Commercial (e.g. Pivotal RTI).
In 2014 we started collaborating on the emerging <<gettingstarted.adoc/#reactivestreams,Reactive Streams Standard>> and proceeded to a massive re-engineering targeting April 2015 version 2.0.1.RELEASE.
The standard closed the last gap our _Dispatching_ mechanism was still having: controlling how much in-flight data was possibly hitting our boundaries.

Parallel to that work we also decided to re-align some of our Event-Driven and Task Coordination API to the increasingly popular and documented <<gettingstarted.adoc/#rx,Reactive Extensions>>.

Reactor is sponsored by http://pivotal.io[Pivotal] where the two core committers actually work. We do try to provide an incentive to our cousin Spring user base.
However we do not force our community into adopting Spring and we remain an embedable toolkit for the mass (Well, wait to see the goodies offered by those guys).
In fact one of the Reactor goals is to stay non-opinonated in the way you solve your asynchronous and functional issues.

Reactor is http://www.apache.org/licenses/LICENSE-2.0.html[Apache 2.0 licensed] and available on https://github.com/reactor/reactor[GitHub].

=== Requirements

* Reactor needs Java 7 at least to execute.
** The full expressive potential happens with Java 8 Lambdas.
** As a fallback have a look at Spring, Clojure or Groovy extensions
* Reactor runs at full capacity when the JVM supports *Unsafe* access (e.g., not the case for Android)
** All *RingBuffer* based features will not work when Unsafe is missing
* Reactor is packaged as JAR archives and can be pulled in any project as a dependency

[[architecture]]
=== Architecture Overview
.The main modules present in Reactor 2
image::images/modules.png[Module Organization, width=500]

[[reactivestreams]]
=== Reactive Streams

http://www.reactive-streams.org[Reactive Streams] is a new standard, adopted by different vendors and tech industrials including Oracle with a target to include the specification into Java 9 and onwards.

The aim of the standard is to provide (a)synchronous data sequences with a flow-control mechanism. The specification is fairly light and first targets the JVM.
It comes with 4 Java Interfaces, a TCK and a handful of examples. It is quite straightforward to implement the 4 interfaces for the need,
but the meat of the project is actually the behaviors verified by the TCK. A provider like Reactor is qualified _Reactive Streams Ready_ when
it successfully passed the TCK for the implementing classes, which fortunately we do.

.The Reactive Streams Contract
image::images/rs.png[The Reactive Streams Contract, width=500]

*TBD Summary of RS*

We have worked with the standard since the inception of Reactor 2 and progressed in our journey until the *1.0.0* was about to release.
It is now available on _Maven Central_ and other popular mirrors. You will also find it as a *transitive dependency to reactor-core*.

[[rx]]
=== Reactive Extensions

Reactive Extensions, or more commonly https://msdn.microsoft.com/en-gb/data/gg577609.aspx[Rx],
are a set of well-defined Functional APIs extending the Observable pattern to an epic scale.

*TBD Summary of Rx*

The standard implementation of Reactive Extensions in the JVM is https://github.com/ReactiveX/RxJava[RxJava].
It provides a powerful functional API and ports mostly all the concept over from the original Microsoft library.

Reactor 2 provides a <<streams.adoc#streams,specific module>> implementing a subset of the documented Extensions and on a very few occasion adapting the name
to match our specific behavior. This focused approach around data-centric issues (microbatching, composition...) is depending on
Reactor <<core.adoc#core-functional,Functional>> units, <<core.adoc#core-dispatchers,Dispatchers>> and <<gettingstarted.adoc#reactive-streams>> contract.
We encourage users who need the full flavor of Reactive Extensions to try out RxJava and https://github.com/ReactiveX/RxJavaReactiveStreams[bridge with us].
In the end the user can benefit from powerful asynchronous and IO capacities provided by Reactor while composing with the complete RxJava ecosystem.

NOTE: Some operations, behaviors, and the immediate understanding of Reactive Streams are still unique to Reactor as of now and we will try to flesh out
the unique features in the <<streams.adoc#streams,appropriate section>>.

IMPORTANT: <<net.adoc#net-overview,Async IO>> capabilities are also depending on _Stream Capacity_ for
backpressure and auto-flush options.

.Main differences between Rx and Reactor Streams
[cols="3*", options="header"]
|===

|rx
|reactor-stream
|Comment

|Observable
|reactor.rx.Stream
|Reflect the implementation of the Reactive Stream Publisher

|Operator
|reactor.rx.action.Action
|Reflect the implementation of the Reactive Stream Processor

|Observable with 1 data at most
|reactor.rx.Promise
|Type a unique result, reflect the implementation of the Reactive Stream Processor and provides for optional asynchronous dispatching.

|Factory API (just, from, merge....)
|reactor.rx.Streams
|Aligned with a core data-focused subset, return Stream

|Functional API (map, filter, take....)
|reactor.rx.Stream
|Aligned with a core data-focused subset, return Stream

|Schedulers
|reactor.core.Dispatcher, org.reactivestreams.Processor
|Reactor Streams compute operations with unbounded shared Dispatchers or bounded Processors

|Observable.observeOn()
|Stream.dispatchOn()
|Just an adapted naming for the dispatcher argument

|===